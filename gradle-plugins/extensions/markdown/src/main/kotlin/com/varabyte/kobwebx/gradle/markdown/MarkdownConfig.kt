@file:Suppress("LeakingThis") // Following official Gradle guidance

package com.varabyte.kobwebx.gradle.markdown

import com.varabyte.kobweb.gradle.application.extensions.hasDependencyNamed
import com.varabyte.kobwebx.gradle.markdown.ext.kobwebcall.KobwebCallExtension
import org.commonmark.Extension
import org.commonmark.ext.autolink.AutolinkExtension
import org.commonmark.ext.front.matter.YamlFrontMatterExtension
import org.commonmark.ext.gfm.tables.TableBlock
import org.commonmark.ext.gfm.tables.TableBody
import org.commonmark.ext.gfm.tables.TableCell
import org.commonmark.ext.gfm.tables.TableHead
import org.commonmark.ext.gfm.tables.TableRow
import org.commonmark.ext.gfm.tables.TablesExtension
import org.commonmark.ext.task.list.items.TaskListItemsExtension
import org.commonmark.node.*
import org.commonmark.parser.Parser
import org.gradle.api.Project
import org.gradle.api.provider.Property
import javax.inject.Inject

abstract class MarkdownConfig {
    /**
     * The path to all markdown resources to process.
     *
     * This path should live in the root of the project's `resources` folder, e.g. `src/jsMain/resources`
     */
    abstract val markdownPath: Property<String>

    init {
        markdownPath.convention("markdown")
    }
}

/**
 * List feature extensions to markdown that this plugin supports.
 *
 * This block will be nested under [MarkdownConfig], e.g.
 *
 * ```
 * kobwebx {
 *   markdown {
 *     features { ... }
 *   }
 * }
 * ```
 */
abstract class MarkdownFeatures {
    /**
     * If true, convert URLs and email addresses into links automatically.
     *
     * See also: https://github.com/commonmark/commonmark-java#autolink
     */
    abstract val autolink: Property<Boolean>

    /**
     * If true, support front matter (a header YAML block at the top of your markdown file with key/value pairs)
     *
     * See also: https://github.com/commonmark/commonmark-java#yaml-front-matter
     */
    abstract val frontMatter: Property<Boolean>

    /**
     * If true, support a syntax for inserting a composable call into the final generated Kotlin source:
     *
     * ```
     * {{{ .components.widgets.VisitorCounter }}}
     * ```
     *
     * becomes:
     *
     * ```
     * org.example.myproject.components.widgets.VisitorCounter()
     * ```
     */
    abstract val kobwebCall: Property<Boolean>

    /**
     * The delimiters used to delineate code for the [kobwebCall] feature.
     *
     * By default, it is curly braces `{}` but you can change the character if this
     * causes a problem in your project for some unforeseeable reason.
     */
    abstract val kobwebCallDelimiters: Property<Pair<Char, Char>>

    /**
     * If true, support creating tables via pipe syntax.
     *
     * See also: https://github.com/commonmark/commonmark-java#tables
     * See also: https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables
     */
    abstract val tables: Property<Boolean>

    /**
     * If true, support creating task list items via a convenient syntax:
     *
     * ```
     * - [ ] task #1
     * - [x] task #2
     * ```
     *
     * See also: https://github.com/commonmark/commonmark-java#task-list-items
     */
    abstract val taskList: Property<Boolean>

    init {
        autolink.convention(true)
        frontMatter.convention(true)
        kobwebCall.convention(true)
        kobwebCallDelimiters.convention('{' to '}')
        tables.convention(true)
        taskList.convention(true)
    }

    /**
     * Create a markdown parser configured based on the currently activated features.
     */
    fun createParser(): Parser {
        val extensions = mutableListOf<Extension>()
        if (autolink.get()) {
            extensions.add(AutolinkExtension.create())
        }
        if (frontMatter.get()) {
            extensions.add(YamlFrontMatterExtension.create())
        }
        if (kobwebCall.get()) {
            extensions.add(KobwebCallExtension.create(kobwebCallDelimiters.get()))
        }
        if (tables.get()) {
            extensions.add(TablesExtension.create())
        }
        if (taskList.get()) {
            extensions.add(TaskListItemsExtension.create())
        }

        return Parser.builder()
            .extensions(extensions)
            .build()
    }
}

private const val JB_DOM = "org.jetbrains.compose.web.dom"
private const val KOBWEB_DOM = "com.varabyte.kobweb.compose.dom"
private const val SILK = "com.varabyte.kobweb.silk.components"

class NodeScope {
    /** If set, will cause the Markdown visit to visit these nodes instead of the node's original children. */
    var childrenOverride: List<Node>? = null
}

/**
 * Specify which composable components should be used to render various html tags generated by the markdown parser.
 *
 * This block will be nested under [MarkdownConfig], e.g.
 *
 * ```
 * kobwebx {
 *   markdown {
 *     components { ... }
 *   }
 * }
 * ```
 */
abstract class MarkdownComponents @Inject constructor(project: Project) {
    /**
     * Use Silk components instead of Compose for Web components when relevant.
     *
     * If the user's project doesn't have a dependency on the Silk library, this should be set to false.
     */
    abstract val useSilk: Property<Boolean>

    /**
     * If true, attach an auto-generated header ID to each header element.
     *
     * For example,
     *
     * ```markdown
     * # This Is A Section
     * ```
     *
     * will generate a header tag with `id="this-is-a-section"`
     *
     * See also [idGenerator] if you need to override the default algorithm used for generating these IDs.
     */
    abstract val generateHeaderIds: Property<Boolean>

    /**
     * Handler for converting some incoming text (fairly unconstrained) into a final string value that should be used as
     * an ID for a URL fragment.
     *
     * By default, this simply only accepts letters and digits and converts everything else to hyphens (while removing
     * any duplicate neighboring hyphens), producing a lowercase value.
     *
     * However, if your project needs more fine-grained control over the generated names, you can set this callback
     * however you see fit.
     *
     * If you override this callback, you may want to check with https://www.rfc-editor.org/rfc/rfc3986 to ensure the ID
     * generated is valid.
     *
     * See also: [generateHeaderIds]
     */
    abstract val idGenerator: Property<(String) -> String>


    abstract val text: Property<NodeScope.(Text) -> String>
    abstract val img: Property<NodeScope.(Image) -> String>
    abstract val heading: Property<NodeScope.(Heading) -> String>
    abstract val p: Property<NodeScope.(Paragraph) -> String>
    abstract val br: Property<NodeScope.(HardLineBreak) -> String>
    abstract val a: Property<NodeScope.(Link) -> String>
    abstract val em: Property<NodeScope.(Emphasis) -> String>
    abstract val strong: Property<NodeScope.(StrongEmphasis) -> String>
    abstract val hr: Property<NodeScope.(ThematicBreak) -> String>
    abstract val ul: Property<NodeScope.(BulletList) -> String>
    abstract val ol: Property<NodeScope.(OrderedList) -> String>
    abstract val li: Property<NodeScope.(ListItem) -> String>
    abstract val code: Property<NodeScope.(FencedCodeBlock) -> String>
    abstract val inlineCode: Property<NodeScope.(Code) -> String>
    abstract val table: Property<NodeScope.(TableBlock) -> String>
    abstract val thead: Property<NodeScope.(TableHead) -> String>
    abstract val tbody: Property<NodeScope.(TableBody) -> String>
    abstract val tr: Property<NodeScope.(TableRow) -> String>
    abstract val td: Property<NodeScope.(TableCell) -> String>
    abstract val th: Property<NodeScope.(TableCell) -> String>

    /** Handler which is fed the raw text (name and attributes) within an opening tag, e.g. `span id="demo"` */
    abstract val rawTag: Property<NodeScope.(String) -> String>
    abstract val inlineTag: Property<NodeScope.(HtmlInline) -> String>

    init {
        project.afterEvaluate {
            useSilk.convention(project.hasDependencyNamed("kobweb-silk"))
        }

        generateHeaderIds.convention(true)
        idGenerator.convention { text ->
            val mergedText = text
                .map { c ->
                    when {
                        c.isLetterOrDigit() -> c.toLowerCase()
                        else -> '-'
                    }
                }
                .joinToString("")

            // Regexes are hard to read, so what's happening here is sometimes multiple special characters / spaces
            // could end up next to each other, causing double (or more) repeated dashes. We compress those so the
            // string doesn't look weird.
            mergedText
                .replace(Regex("""--+"""), "-")
                .removePrefix("-")
                .removeSuffix("-")
        }

        // region Markdown Node handlers

        text.convention { text ->
            val literal = text.literal.escapeQuotes()
            if (useSilk.get()) {
                "$SILK.text.Text(\"${literal}\")"
            } else {
                "$JB_DOM.Text(\"${literal}\")"
            }
        }
        img.convention { "$JB_DOM.Img" }
        heading.convention { heading ->
            buildString {
                append("$JB_DOM.H${heading.level}")
                if (generateHeaderIds.get()) {
                    val text = heading.children()
                        .filterIsInstance<Text>()
                        .map { it.literal }
                        .joinToString("")
                    val id = idGenerator.get().invoke(text)
                    append("(attrs = { id(\"$id\") })")
                }
            }
        }
        p.convention { "$JB_DOM.P" }
        br.convention { "$JB_DOM.Br" }
        a.convention { link ->
            if (useSilk.get()) {
                val linkText = link.children().filterIsInstance<Text>().firstOrNull()?.literal?.escapeQuotes().orEmpty()
                childrenOverride = listOf() // We "consumed" the children, no more need to visit them
                "$SILK.navigation.Link(\"${link.destination}\", \"$linkText\")"
            } else {
                "$JB_DOM.A(\"${link.destination}\")"
            }
        }
        em.convention { "$JB_DOM.Em" }
        strong.convention { "$JB_DOM.B" }
        hr.convention { "$JB_DOM.Hr" }
        ul.convention { "$JB_DOM.Ul" }
        ol.convention { "$JB_DOM.Ol" }
        li.convention { "$JB_DOM.Li" }
        code.convention { codeBlock ->
            val text = "\"\"\"${codeBlock.literal}\"\"\""
            // Code blocks should generate <pre><code>...</code></pre>
            // https://daringfireball.net/projects/markdown/syntax#precode
            "$JB_DOM.Pre { $JB_DOM.Code { $JB_DOM.Text($text) } }"
        }
        inlineCode.convention { code ->
            childrenOverride = listOf(Text(code.literal))
            "$JB_DOM.Code"
        }
        table.convention { "$JB_DOM.Table" }
        thead.convention { "$JB_DOM.Thead" }
        tbody.convention { "$JB_DOM.Tbody" }
        tr.convention { "$JB_DOM.Tr" }
        td.convention { "$JB_DOM.Td" }
        th.convention { "$JB_DOM.Th" }

        fun String.stripTagBrackets() =
            this.removePrefix("</").removePrefix("<").removeSuffix("/>").removeSuffix(">")

        rawTag.convention { tag ->
            val parts = tag.stripTagBrackets().split(' ', limit = 2)
            val name = "\"${parts[0]}\""
            val attrs = parts.getOrNull(1)?.escapeQuotes()?.let { "\"$it\""} ?: "null"

            "$KOBWEB_DOM.GenericTag($name, $attrs)"
        }

        inlineTag.set { htmlInline ->
            val tag = htmlInline.literal

            val scope = this
            buildString {
                if (!tag.startsWith("</")) {
                    append(rawTag.get().invoke(scope, tag))
                    if (!tag.endsWith("/>")) {
                        append(" {")
                    }
                } else {
                    // Closing tag
                    append("}")
                }
            }
        }

        // endregion
    }
}