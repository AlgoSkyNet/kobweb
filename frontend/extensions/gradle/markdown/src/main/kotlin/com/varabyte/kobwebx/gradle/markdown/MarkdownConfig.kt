@file:Suppress("LeakingThis") // Following official Gradle guidance

package com.varabyte.kobwebx.gradle.markdown

import org.commonmark.ext.gfm.tables.*
import org.commonmark.node.*
import org.gradle.api.provider.Property

abstract class MarkdownConfig {
    /**
     * The path to all markdown resources to process.
     *
     * This path should live in the root of the project's `resources` folder, e.g. `src/jsMain/resources`
     */
    abstract val markdownPath: Property<String>

    init {
        markdownPath.convention("markdown")
    }
}

/**
 * List feature extensions to markdown that this plugin supports.
 *
 * This block will be nested under [MarkdownConfig], e.g.
 *
 * ```
 * kobwebx {
 *   markdown {
 *     features { ... }
 *   }
 * }
 * ```
 */
abstract class MarkdownFeatures {
    /**
     * If true, convert URLs and email addresses into links automatically.
     *
     * See also: https://github.com/commonmark/commonmark-java#autolink
     */
    abstract val autolink: Property<Boolean>

    /**
     * If true, support front matter (a header YAML block at the top of your markdown file with key/value pairs)
     *
     * See also: https://github.com/commonmark/commonmark-java#yaml-front-matter
     */
    abstract val frontMatter: Property<Boolean>

    /**
     * If true, support creating tables via pipe syntax.
     *
     * See also: https://github.com/commonmark/commonmark-java#tables
     * See also: https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables
     */
    abstract val tables: Property<Boolean>

    /**
     * If true, support creating task list items via a convenient syntax:
     *
     * ```
     * - [ ] task #1
     * - [x] task #2
     * ```
     *
     * See also: https://github.com/commonmark/commonmark-java#task-list-items
     */
    abstract val taskList: Property<Boolean>

    init {
        autolink.convention(true)
        frontMatter.convention(true)
        tables.convention(true)
        taskList.convention(true)
    }
}

private const val JB_DOM = "org.jetbrains.compose.web.dom"
private const val SILK = "com.varabyte.kobweb.silk.components"

class NodeScope(val indentCount: Int) {
    var childrenHandled = false
}

/**
 * Specify which composable components should be used to render various html tags generated by the markdown parser.
 *
 * This block will be nested under [MarkdownConfig], e.g.
 *
 * ```
 * kobwebx {
 *   markdown {
 *     components { ... }
 *   }
 * }
 * ```
 */
abstract class MarkdownComponents {
    /**
     * Use Silk components instead of Web Compose components when relevant.
     *
     * If the user's project doesn't have a dependency on the Silk library, this should be set to false.
     */
    abstract val useSilk: Property<Boolean>

    abstract val text: Property<NodeScope.(Text) -> String>
    abstract val img: Property<NodeScope.(Image) -> String>
    abstract val h1: Property<NodeScope.(Heading) -> String>
    abstract val h2: Property<NodeScope.(Heading) -> String>
    abstract val h3: Property<NodeScope.(Heading) -> String>
    abstract val h4: Property<NodeScope.(Heading) -> String>
    abstract val h5: Property<NodeScope.(Heading) -> String>
    abstract val h6: Property<NodeScope.(Heading) -> String>
    abstract val p: Property<NodeScope.(Paragraph) -> String>
    abstract val br: Property<NodeScope.(HardLineBreak) -> String>
    abstract val a: Property<NodeScope.(Link) -> String>
    abstract val em: Property<NodeScope.(Emphasis) -> String>
    abstract val strong: Property<NodeScope.(StrongEmphasis) -> String>
    abstract val hr: Property<NodeScope.(ThematicBreak) -> String>
    abstract val ul: Property<NodeScope.(BulletList) -> String>
    abstract val ol: Property<NodeScope.(OrderedList) -> String>
    abstract val li: Property<NodeScope.(ListItem) -> String>
    abstract val code: Property<NodeScope.(FencedCodeBlock) -> String>
    abstract val inlineCode: Property<NodeScope.(Code) -> String>
    abstract val table: Property<NodeScope.(TableBlock) -> String>
    abstract val thead: Property<NodeScope.(TableHead) -> String>
    abstract val tbody: Property<NodeScope.(TableBody) -> String>
    abstract val tr: Property<NodeScope.(TableRow) -> String>
    abstract val td: Property<NodeScope.(TableCell) -> String>
    abstract val th: Property<NodeScope.(TableCell) -> String>

    init {
        useSilk.convention(true)

        text.convention { text ->
            if (useSilk.get()) {
                "$SILK.text.Text(\"${text.literal}\")"
            } else {
                "$JB_DOM.Text(\"${text.literal}\")"
            }
        }
        img.convention{ "$JB_DOM.Img" }
        h1.convention{ "$JB_DOM.H1" }
        h2.convention{ "$JB_DOM.H2" }
        h3.convention{ "$JB_DOM.H3" }
        h4.convention{ "$JB_DOM.H4" }
        h5.convention{ "$JB_DOM.H5" }
        h6.convention{ "$JB_DOM.H6" }
        p.convention{ "$JB_DOM.P" }
        br.convention{ "$JB_DOM.Br" }
        a.convention { link ->
            if (useSilk.get()) {
                childrenHandled = true
                val linkText = link.children().filterIsInstance<Text>().firstOrNull()?.literal.orEmpty()
                "$SILK.navigation.Link(\"${link.destination}\", \"$linkText\")"
            } else {
                "$JB_DOM.A(\"${link.destination}\")"
            }
        }
        em.convention{ "$JB_DOM.Em" }
        strong.convention{ "$JB_DOM.B" }
        hr.convention{ "$JB_DOM.Hr" }
        ul.convention{ "$JB_DOM.Ul" }
        ol.convention{ "$JB_DOM.Ol" }
        li.convention{ "$JB_DOM.Li" }
        code.convention{ "$JB_DOM.Code()" }
        inlineCode.convention{ code -> "$JB_DOM.Code { ${text.get().invoke(this, Text(code.literal))} }" }
        table.convention{ "$JB_DOM.Table" }
        thead.convention{ "$JB_DOM.Thead" }
        tbody.convention{ "$JB_DOM.Tbody" }
        tr.convention{ "$JB_DOM.Tr" }
        td.convention{ "$JB_DOM.Td" }
        th.convention{ "$JB_DOM.Th" }
    }
}